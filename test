  ruby {
    init => '
      @fields_to_check = ["field1", "another_field", "yet_another"] # Replace with your actual field names
      @regex = /.*pipe.*/
    '
    code => '
      @fields_to_check.each do |field|
        if event.get(field).is_a?(String) && event.get(field) =~ @regex
          event.remove(field)
        end
      end
    '
  }




filter {
  if [type] == "paloalto" {
    grok {
      match => {
        "message" => [
          "<%{POSINT:syslog_priority}>%{SYSLOGTIMESTAMP:syslog_timestamp} %{HOSTNAME:hostname} %{GREEDYDATA:paloalto_message}"
        ]
      }
    }
  }
}


  if [key_value_pairs] {
    kv {
      source => "key_value_pairs"
      field_split => ", "
      value_split => "="
      trim => " "
    }
  }
  if [cmd_set_data] {
    ruby {
      init => '
        @command_parts_regex = /Cmd(AV|ArgAV)=([^ ]+)/
      '
      code => '
        command_parts = event.get("cmd_set_data").scan(@command_parts_regex)
        cisco_command_parts = []
        command_parts.each do |part_type, part_value|
          cisco_command_parts << part_value unless part_type == "AV" && part_value == "show"
        end
        event.set("cisco_command", cisco_command_parts.join(" "))
      '
    }
    mutate {
      remove_field => "cmd_set_data"
    }
  }
  mutate {
    remove_field => "key_value_pairs"

([a-z0-9\-]+-\d+-\d+)(?=\.[a-z0-9\-]+(?:\.[a-z0-9\-]+)*$)


net.core.somaxconn=2048
net.core.netdev_max_backlog=2048
net.core.rmem_max=33554432
net.core.rmem_default=262144
net.ipv4.udp_rmem_min=16384
net.ipv4.udp_mem="2097152 4194304 8388608â€




tcp:
net.core.rmem_max = 67108864
net.core.wmem_max = 67108864

# TCP-Specific Buffer Autotuning Limits (allow autotuning up to 32MB)
net.ipv4.tcp_rmem = 4096 87380 33554432
net.ipv4.tcp_wmem = 4096 65536 33554432

# Increase backlogs for incoming connections/packets
net.core.netdev_max_backlog = 250000
net.ipv4.tcp_max_syn_backlog = 8192

# TIME_WAIT state management (use with caution, especially tcp_tw_reuse)
# This is mainly for many short-lived TCP connections.
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 30
net.ipv4.tcp_max_tw_buckets = 262144

# Increase maximum backlog for listening sockets
net.core.somaxconn = 65535



filter {
  grok {
    match => { "message" => "<%{POSINT:syslog_priority}>%{SYSLOGTIMESTAMP:syslog_timestamp} %{HOSTNAME:syslog_hostname} %{DATA:syslog_program}: \{%{GREEDYDATA:kv_payload}\}" }
  }

  kv {
    source => "kv_payload"
    field_split => ","
    value_split => ":"
    # This is the most important part: remove quotes and spaces from both sides
    trim_key => " \" "
    trim_value => " \" "
  }

  ruby {
    init => "require 'base64'"
    code => "
      # List the fields you know are encoded
      target_fields = ['username', 'app'] 
      
      target_fields.each do |field|
        value = event.get(field)
        if value
          begin
            event.set(field, Base64.decode64(value).force_encoding('UTF-8'))
          rescue
            event.tag('_decode_fail_' + field)
          end
        end
      end
    "
  }
}




if [destination_ip] {
    # Check to ensure it's not a private/internal IP address
    if [destination_ip] !~ /^10\./ and [destination_ip] !~ /^192\.168\./ and [destination_ip] !~ /^172\.(1[6-9]|2[0-9]|3[0-1])\./ {
      geoip {
        source => "destination_ip"
        target => "geo"
        fields => ["city_name", "country_name", "location", "region_name"]
      }
    }
  }
}

wget https://artifacts.elastic.co/downloads/logstash/logstash-8.18.3-linux-x86_64.tar.gz
    tar -xzf logstash-8.18.3-linux-x86_64.tar.gz
    cd logstash-8.18.3
    bin/logstash-plugin install logstash-codec-sflow
    bin/logstash-plugin prepare-offline-pack --output ../sflow-8-18-3.zip logstash-codec-sflow
    cd ..

bin/logstash-plugin prepare-offline-pack --output $(Build.ArtifactStagingDirectory)/sflow-8-18-3.zip logstash-codec-sflow

- task: PublishBuildArtifacts@1
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)/sflow-8-18-3.zip'
    ArtifactName: 'logstash-plugin-pack'
    publishLocation: 'Container'


translate {
  field => "eth_type"
  destination => "eth_type"
  dictionary => {
    "2048"  => "IPv4"
    "2054"  => "ARP"
    "2114"  => "WOL"
    "8944"  => "AVTP"
    "32821" => "RARP"
    "32923" => "AppleTalk"
    "33024" => "VLAN"
    "33079" => "IPX"
    "34525" => "IPv6"
    "34825" => "Slow-Protocols-LACP"
    "34827" => "PPP"
    "34887" => "MPLS_Unicast"
    "34888" => "MPLS_Multicast"
    "34915" => "PPPoE_Discovery"
    "34916" => "PPPoE_Session"
    "34927" => "Jumbo_Frames"
    "34939" => "HomePlug_AV"
    "34958" => "EAPOL"
    "34962" => "PROFINET"
    "34970" => "Hyperscsi"
    "34978" => "ATA_over_Ethernet"
    "34984" => "EtherCAT"
    "34991" => "Provider_Bridging"
    "35020" => "LLDP"
    "35041" => "SERCOS_III"
    "35045" => "ESMC"
    "35067" => "PBB"
    "35078" => "MRP"
    "35093" => "IEEE_802.1AE"
    "35138" => "PTP"
    "35142" => "NC-SI"
    "35143" => "PRP"
    "35151" => "CFM"
    "36864" => "Loop"
    "37120" => "QinQ"
    "37376" => "TRILL"
    "37424" => "DECnet"
    "4660"  => "HSR"
    "65280" => "RoCE_v1"
  }

    "0"   => "HOPOPT"
    "1"   => "ICMP"
    "2"   => "IGMP"
    "3"   => "GGP"
    "4"   => "IPv4"
    "5"   => "ST"
    "6"   => "TCP"
    "7"   => "CBT"
    "8"   => "EGP"
    "9"   => "IGP"
    "17"  => "UDP"
    "18"  => "MUX"
    "27"  => "RDP"
    "41"  => "IPv6"
    "43"  => "IPv6-Route"
    "44"  => "IPv6-Frag"
    "46"  => "RSVP"
    "47"  => "GRE"
    "50"  => "ESP"
    "51"  => "AH"
    "58"  => "IPv6-ICMP"
    "59"  => "IPv6-NoNxt"
    "60"  => "IPv6-Opts"
    "88"  => "EIGRP"
    "89"  => "OSPF"
    "94"  => "IPIP"
    "97"  => "ETHERIP"
    "98"  => "ENCAP"
    "103" => "PIM"
    "112" => "VRRP"
    "115" => "L2TP"
    "132" => "SCTP"
    "137" => "MPLS-in-IP"
