  ruby {
    init => '
      @fields_to_check = ["field1", "another_field", "yet_another"] # Replace with your actual field names
      @regex = /.*pipe.*/
    '
    code => '
      @fields_to_check.each do |field|
        if event.get(field).is_a?(String) && event.get(field) =~ @regex
          event.remove(field)
        end
      end
    '
  }




filter {
  if [type] == "paloalto" {
    grok {
      match => {
        "message" => [
          "<%{POSINT:syslog_priority}>%{SYSLOGTIMESTAMP:syslog_timestamp} %{HOSTNAME:hostname} %{GREEDYDATA:paloalto_message}"
        ]
      }
    }
  }
}


  if [key_value_pairs] {
    kv {
      source => "key_value_pairs"
      field_split => ", "
      value_split => "="
      trim => " "
    }
  }
  if [cmd_set_data] {
    ruby {
      init => '
        @command_parts_regex = /Cmd(AV|ArgAV)=([^ ]+)/
      '
      code => '
        command_parts = event.get("cmd_set_data").scan(@command_parts_regex)
        cisco_command_parts = []
        command_parts.each do |part_type, part_value|
          cisco_command_parts << part_value unless part_type == "AV" && part_value == "show"
        end
        event.set("cisco_command", cisco_command_parts.join(" "))
      '
    }
    mutate {
      remove_field => "cmd_set_data"
    }
  }
  mutate {
    remove_field => "key_value_pairs"

([a-z0-9\-]+-\d+-\d+)(?=\.[a-z0-9\-]+(?:\.[a-z0-9\-]+)*$)


net.core.somaxconn=2048
net.core.netdev_max_backlog=2048
net.core.rmem_max=33554432
net.core.rmem_default=262144
net.ipv4.udp_rmem_min=16384
net.ipv4.udp_mem="2097152 4194304 8388608â€




tcp:
net.core.rmem_max = 67108864
net.core.wmem_max = 67108864

# TCP-Specific Buffer Autotuning Limits (allow autotuning up to 32MB)
net.ipv4.tcp_rmem = 4096 87380 33554432
net.ipv4.tcp_wmem = 4096 65536 33554432

# Increase backlogs for incoming connections/packets
net.core.netdev_max_backlog = 250000
net.ipv4.tcp_max_syn_backlog = 8192

# TIME_WAIT state management (use with caution, especially tcp_tw_reuse)
# This is mainly for many short-lived TCP connections.
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 30
net.ipv4.tcp_max_tw_buckets = 262144

# Increase maximum backlog for listening sockets
net.core.somaxconn = 65535



filter {
  grok {
    match => { "message" => "<%{POSINT:syslog_priority}>%{SYSLOGTIMESTAMP:syslog_timestamp} %{HOSTNAME:syslog_hostname} %{DATA:syslog_program}: \{%{GREEDYDATA:kv_payload}\}" }
  }

  kv {
    source => "kv_payload"
    field_split => ","
    value_split => ":"
    # This is the most important part: remove quotes and spaces from both sides
    trim_key => " \" "
    trim_value => " \" "
  }

  ruby {
    init => "require 'base64'"
    code => "
      # List the fields you know are encoded
      target_fields = ['username', 'app'] 
      
      target_fields.each do |field|
        value = event.get(field)
        if value
          begin
            event.set(field, Base64.decode64(value).force_encoding('UTF-8'))
          rescue
            event.tag('_decode_fail_' + field)
          end
        end
      end
    "
  }
}




if [destination_ip] {
    # Check to ensure it's not a private/internal IP address
    if [destination_ip] !~ /^10\./ and [destination_ip] !~ /^192\.168\./ and [destination_ip] !~ /^172\.(1[6-9]|2[0-9]|3[0-1])\./ {
      geoip {
        source => "destination_ip"
        target => "geo"
        fields => ["city_name", "country_name", "location", "region_name"]
      }
    }
  }
}

wget https://artifacts.elastic.co/downloads/logstash/logstash-8.18.3-linux-x86_64.tar.gz
    tar -xzf logstash-8.18.3-linux-x86_64.tar.gz
    cd logstash-8.18.3
    bin/logstash-plugin install logstash-codec-sflow
    bin/logstash-plugin prepare-offline-pack --output ../sflow-8-18-3.zip logstash-codec-sflow
    cd ..

bin/logstash-plugin prepare-offline-pack --output $(Build.ArtifactStagingDirectory)/sflow-8-18-3.zip logstash-codec-sflow

- task: PublishBuildArtifacts@1
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)/sflow-8-18-3.zip'
    ArtifactName: 'logstash-plugin-pack'
    publishLocation: 'Container'




     "0"   => "HOPOPT"           # IPv6 Hop-by-Hop Option
    "1"   => "ICMP"             # Internet Control Message Protocol
    "2"   => "IGMP"             # Internet Group Management Protocol
    "3"   => "GGP"              # Gateway-to-Gateway Protocol
    "4"   => "IPv4"             # IPv4 encapsulation
    "5"   => "ST"               # Stream
    "6"   => "TCP"              # Transmission Control Protocol
    "7"   => "CBT"              # CBT
    "8"   => "EGP"              # Exterior Gateway Protocol
    "9"   => "IGP"              # any private interior gateway
    "17"  => "UDP"              # User Datagram Protocol
    "18"  => "MUX"              # Multiplexing
    "27"  => "RDP"              # Reliable Data Protocol
    "41"  => "IPv6"             # IPv6 encapsulation
    "43"  => "IPv6-Route"       # Routing Header for IPv6
    "44"  => "IPv6-Frag"        # Fragment Header for IPv6
    "46"  => "RSVP"             # Reservation Protocol
    "47"  => "GRE"              # Generic Routing Encapsulation
    "50"  => "ESP"              # Encap Security Payload (IPsec)
    "51"  => "AH"               # Authentication Header (IPsec)
    "58"  => "IPv6-ICMP"        # ICMP for IPv6
    "59"  => "IPv6-NoNxt"       # No Next Header for IPv6
    "60"  => "IPv6-Opts"        # Destination Options for IPv6
    "88"  => "EIGRP"            # Enhanced Interior Gateway Routing Protocol
    "89"  => "OSPF"             # Open Shortest Path First
    "94"  => "IPIP"             # IP-within-IP Encapsulation
    "97"  => "ETHERIP"          # Ethernet-within-IP Encapsulation
    "98"  => "ENCAP"            # Encapsulation Header
    "103" => "PIM"              # Protocol Independent Multicast
    "112" => "VRRP"             # Virtual Router Redundancy Protocol
    "115" => "L2TP"             # Layer Two Tunneling Protocol
    "132" => "SCTP"             # Stream Control Transmission Protocol
    "137" => "MPLS-in-IP"       # MPLS-in-IP
